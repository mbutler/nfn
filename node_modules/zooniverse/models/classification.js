// Generated by CoffeeScript 1.4.0
(function() {
  var $, Api, BaseModel, Classification, Favorite, RESOLVED_STATE, Recent, _base, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  if ((_ref = window.zooniverse) == null) {
    window.zooniverse = {};
  }

  if ((_ref1 = (_base = window.zooniverse).models) == null) {
    _base.models = {};
  }

  BaseModel = window.zooniverse.models.BaseModel || require('./base-model');

  Api = window.zooniverse.Api || require('../lib/api');

  Recent = window.zooniverse.models.Recent || require('../models/recent');

  Favorite = window.zooniverse.models.Favorite || require('../models/favorite');

  $ = window.jQuery;

  RESOLVED_STATE = (new $.Deferred).resolve().state();

  Classification = (function(_super) {

    __extends(Classification, _super);

    Classification.pending = JSON.parse(localStorage.getItem('pending-classifications')) || [];

    Classification.sentThisSession = 0;

    Classification.sendPending = function() {
      var classification, pendingPosts, _i, _len, _ref2, _results,
        _this = this;
      if (this.pending.length === 0) {
        return;
      }
      this.trigger('sending-pending', [classification]);
      pendingPosts = [];
      _ref2 = this.pending;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        classification = _ref2[_i];
        _results.push((function(classification) {
          var latePost;
          latePost = Api.current.post(classification.url, classification);
          pendingPosts.push(latePost);
          latePost.done(function(response) {
            var favorite, id;
            _this.trigger('send-pending', [classification]);
            if (classification.favorite) {
              favorite = new Favorite({
                subjects: (function() {
                  var _j, _len1, _ref3, _results1;
                  _ref3 = classification.subject_ids;
                  _results1 = [];
                  for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
                    id = _ref3[_j];
                    _results1.push({
                      id: id
                    });
                  }
                  return _results1;
                })()
              });
              return favorite.send();
            }
          });
          latePost.fail(function() {
            return _this.trigger('send-pending-fail', [classification]);
          });
          return $.when.apply($, pendingPosts).always(function() {
            var i, _j, _ref3;
            for (i = _j = _ref3 = pendingPosts.length - 1; _ref3 <= 0 ? _j <= 0 : _j >= 0; i = _ref3 <= 0 ? ++_j : --_j) {
              if (pendingPosts[i].state() === RESOLVED_STATE) {
                _this.pending.splice(i, 1);
              }
            }
            return localStorage.setItem('pending-classifications', JSON.stringify(_this.pending));
          });
        })(classification));
      }
      return _results;
    };

    Classification.prototype.subject = null;

    Classification.prototype.annotations = null;

    Classification.prototype.favorite = false;

    Classification.prototype.generic = null;

    Classification.prototype.started_at = null;

    Classification.prototype.finished_at = null;

    Classification.prototype.user_agent = null;

    function Classification() {
      var _ref2;
      Classification.__super__.constructor.apply(this, arguments);
      if ((_ref2 = this.annotations) == null) {
        this.annotations = [];
      }
      this.generic = {};
      this.started_at = (new Date).toUTCString();
      this.user_agent = window.navigator.userAgent;
    }

    Classification.prototype.annotate = function(annotation) {
      this.annotations.push(annotation);
      return annotation;
    };

    Classification.prototype.removeAnnotation = function(annotation) {
      var a, i, _i, _len, _ref2;
      _ref2 = this.annotations;
      for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
        a = _ref2[i];
        if (a === annotation) {
          return this.annotations.splice(i, 1);
        }
      }
    };

    Classification.prototype.set = function(key, value) {
      this.generic[key] = value;
      return this.trigger('change', [key, value]);
    };

    Classification.prototype.get = function(key) {
      return this.generic[key];
    };

    Classification.prototype.toJSON = function() {
      var annotation, key, output, value, _ref2;
      output = {
        classification: {
          subject_ids: [this.subject.id],
          annotations: this.annotations.concat([
            {
              started_at: this.started_at,
              finished_at: this.finished_at
            }, {
              user_agent: this.user_agent
            }
          ])
        }
      };
      _ref2 = this.generic;
      for (key in _ref2) {
        value = _ref2[key];
        annotation = {};
        annotation[key] = value;
        output.classification.annotations.push(annotation);
      }
      if (this.favorite) {
        output.classification.favorite = true;
      }
      return output;
    };

    Classification.prototype.url = function() {
      return "/projects/" + Api.current.project + "/workflows/" + this.subject.workflow_ids[0] + "/classifications";
    };

    Classification.prototype.send = function(done, fail) {
      var post, _ref2,
        _this = this;
      if (!this.subject.metadata.tutorial) {
        this.constructor.sentThisSession += 1;
      }
      this.finished_at = (new Date).toUTCString();
      post = (_ref2 = Api.current).post.apply(_ref2, [this.url(), this.toJSON()].concat(__slice.call(arguments)));
      post.done(function() {
        _this.makeRecent();
        return _this.constructor.sendPending();
      });
      post.fail(function() {
        return _this.makePending();
      });
      return this.trigger('send');
    };

    Classification.prototype.makePending = function() {
      var asJSON;
      asJSON = this.toJSON();
      asJSON.url = this.url();
      this.constructor.pending.push(asJSON);
      localStorage.setItem('pending-classifications', JSON.stringify(this.constructor.pending));
      return this.trigger('pending');
    };

    Classification.prototype.makeRecent = function() {
      var favorite, recent;
      recent = new Recent({
        subjects: [this.subject]
      });
      recent.trigger('from-classification');
      if (this.favorite) {
        favorite = new Favorite({
          subjects: [this.subject]
        });
        return favorite.trigger('from-classification');
      }
    };

    return Classification;

  })(BaseModel);

  window.zooniverse.models.Classification = Classification;

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Classification;
  }

}).call(this);
